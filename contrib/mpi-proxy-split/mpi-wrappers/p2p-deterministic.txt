#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <mpi.h>

#define P2P_LOG_MSG "p2p_log_%d.txt"
#define P2P_LOG_REQUEST "p2p_log_request_%d.txt"

#if defined(__cplusplus)
extern "C" {
#endif

// This is an array in the order of the calls to MPI_Recv/MPI_Irecv
struct p2p_log_msg {
  int count;
  MPI_Datatype datatype;
  int source;
  int tag;
  int MPI_ERROR;
  MPI_Comm comm; // comm == MPI_COMM_NULL if this logs a failed MPI_Iprobe
  MPI_Request request;
};
struct p2p_log_request {
  MPI_Request request;
  int source;
  int tag;
};

void p2p_log(int count, MPI_Datatype datatype, int source, int tag,
             MPI_Comm comm, MPI_Status *status, MPI_Request *request);
void  p2p_replay(int count, MPI_Datatype datatype, int *source, int *tag,
                 MPI_Comm comm);
void  p2p_replay_pre_irecv(int count, MPI_Datatype datatype, int *source,
                           int *tag, MPI_Comm comm);
void p2p_replay_post_iprobe(int *source, int *tag,
		            MPI_Comm comm, MPI_Status *status, int *flag);
int get_next_msg_irecv(struct p2p_log_msg *p2p_msg);
int get_next_msg_iprobe(struct p2p_log_msg *p2p_msg);
int iprobe_next_msg(struct p2p_log_msg *p2p_msg);
void set_next_msg(int count, MPI_Datatype datatype,
                  int source, int tag, MPI_Comm comm,
                  MPI_Status *status, MPI_Request *request);
void save_request_info(MPI_Request *request, MPI_Status *status);

#ifdef USE_READALL
static
ssize_t readall(int fd, void *buf, size_t count) {
  ssize_t rc;
  char *ptr = (char *)buf;
  size_t num_read = 0;
  for (num_read = 0; num_read < count;) {
    rc = read(fd, ptr + num_read, count - num_read);
    if (rc == -1 && (errno == EINTR || errno == EAGAIN)) {
      continue;
    } else if (rc == -1) {
      return -1;
    } else if (rc == 0) {
      break;
    } else { // else rc > 0
      num_read += rc;
    }
  }
  return num_read;
}
#endif

#ifdef USE_WRITEALL
static
ssize_t writeall(int fd, void *buf, size_t count) {
  const char *ptr = (const char *)buf;
  size_t num_written = 0;
  do {
    ssize_t rc = write(fd, ptr + num_written, count - num_written);
    if (rc == -1 && (errno == EINTR || errno == EAGAIN)) {
      continue;
    } else if (rc == -1) {
      return rc;
    } else if (rc == 0) {
      break;
    } else { // else rc > 0
      num_written += rc;
    }
  } while (num_written < count);
  return num_written;
}
#endif

/*************************************
 * LOG for MPI_Recv/Irecv/Probe/Iprobe
 *************************************/

// Before MPI_Recv during original launch/log
// NOT USED:  MPI_Recv wrapper calls MPI_Irecv
#define LOG_PRE_Recv(status)
  MPI_Status local_status;
  if (getenv("MANA_P2P_LOG") && status != MPI_STATUS_IGNORE) {
    status = &local_status;
  }

// After MPI_Recv during original launch/log
// NOT USED:  MPI_Recv wrapper calls MPI_Irecv
#define LOG_POST_Recv(source,tag,comm,status,request)
  if (getenv("MANA_P2P_LOG")) {
    p2p_log(bytesRecvd, MPI_CHAR, source, tag, comm,
            status, NULL /* no request */);
  }

// Before MPI_Irecv during original launch/log
//   no status; nothing to do
#define LOG_PRE_Irecv(status)

// After MPI_Irecv during original launch/log
// FIXME:  Need to add MPI_Recv_init when MANA supports it
#define LOG_POST_Irecv(source,tag,comm,status,request)
  if (getenv("MANA_P2P_LOG")) {
    // source and tag will be filled in later, based on request
    // (count, datatype) will be replaced by (bytesRecvd, MPI_CHAR)
    p2p_log(count, datatype, source, tag, comm, NULL, request);
  }

// Before MPI_Probe during original launch/log
// NOT USED:  MPI_Probe wrapper calls MPI_Iprobe
#define LOG_PRE_Probe(status)
  MPI_Status local_status;
  if (getenv("MANA_P2P_LOG") && status != MPI_STATUS_IGNORE) {
    status = &local_status;
  }

// After MPI_Probe during original launch/log
// NOT USED:  MPI_Probe wrapper calls MPI_Iprobe
#define LOG_POST_Probe(source,tag,comm,status,request)
  if (getenv("MANA_P2P_LOG")) {
    p2p_log(count, MPI_CHAR, source, tag, comm, status, NULL /* no request */);
  }

// Before MPI_Iprobe during original launch/log
// FIXME:  Need to add MPI_Improbe when MANA supports it
#define LOG_PRE_Iprobe(status)
  MPI_Status local_status;
  if (getenv("MANA_P2P_LOG") && status == MPI_STATUS_IGNORE) {
    status = &local_status;
  }

// After MPI_Iprobe during original launch/log
// FIXME:  Need to add MPI_Improbe when MANA supports it
#define LOG_POST_Iprobe(source,tag,comm,status)
  if (getenv("MANA_P2P_LOG")) {
    int bytesRecvd = -1;
    if (*flag == 0) {
      comm = MPI_COMM_NULL; // This implies MPI_Iprobe flag returned false
    } else {
      // FIXME:  p2p_log() does a lot of this.
      MPI_Get_count(status, MPI_CHAR, &bytesRecvd); // Get count in bytes
      source = status->MPI_SOURCE;
      tag = status->MPI_TAG;
    }
    p2p_log(bytesRecvd, MPI_CHAR, source, tag, comm,
            status, NULL /* no request */);
  }

/****************************************
 * REPLAY for MPI_Recv/Irecv/Probe/Iprobe
 ****************************************/

// Before MPI_Recv during replay
// NOT USED:  MPI_Recv wrapper calls MPI_Irecv
#define REPLAY_PRE_Recv(count,datatype,source,tag,comm)
  if (getenv("MANA_P2P_REPLAY")) {
    p2p_replay(count, datatype, &source, &tag, comm);
  }

// Before call to MPI_Irecv() in lower half during replay
// FIXME:  Need to add MPI_Recv_init when MANA supports it
#define REPLAY_PRE_Irecv(count,datatype,source,tag,comm)
  if (getenv("MANA_P2P_REPLAY")) {
    p2p_replay_pre_irecv(count,datatype,&source,&tag,comm);
  }

// Before MPI_Probe during replay
// NOT USED:  MPI_Probe wrapper calls MPI_Iprobe
#define REPLAY_PRE_Probe(count,datatype,source,tag,comm)
  if (getenv("MANA_P2P_REPLAY")) {
    p2p_replay(count, datatype, &source, &tag, comm);
  }

// After call to MPI_Iprobe() in lower half during replay
//   Make sure log is in sync with MPI_Iprobe again.
// FIXME:  Need to add MPI_Improbe when MANA supports it
#define REPLAY_POST_Iprobe(source,tag,comm,status,flag)
  if (getenv("MANA_P2P_REPLAY")) {
    p2p_replay_post_iprobe(&source,&tag,comm,status,flag);
  }

/************************************************
 * LOG for MPI_Wait/Test/Waitsome/Waitany/Waitall
 ************************************************/

// Before MPI_Wait, MPI_Test during log/launch
// NOT USED:  MPI_Wait wrapper calls MPI_Test
#define LOG_PRE_Wait(status)

#define LOG_PRE_Test(status) LOG_PRE_Wait(status)

// After MPI_Wait, MPI_Test during log/launch
#define LOG_POST_Wait(request,status)
  if (getenv("MANA_P2P_LOG")) {
    if (flag) {
      save_request_info(request, status);
    }
  }

#define LOG_POST_Test(request,status) LOG_POST_Wait(request,status)

// FIXME:  Add MPI_Waitsome/MPI_Waitany/MPI_Waitall
//         Also, need to take account of MPI_STATUSES_IGNORE

/************************************************
 * REPLAY for MPI_Wait/Test/Waitsome/Waitany/Waitall
 ************************************************/

// FIXME:  Are these needed for REPLAY for MPI_Wait and MPI_Test?
// Before MPI_Wait, MPI_Test during replay
#define REPLAY_PRE_Wait(status)
  MPI_Status local_status;
  if (getenv("MANA_P2P_LOG") && status != MPI_STATUS_IGNORE) {
    status = &local_status;
  }

#define REPLAY_PRE_Test(status) REPLAY_PRE_Wait(status)

// FIXME:  Add MPI_Waitsome/MPI_Waitany/MPI_Waitall
//         Also, need to take account of MPI_STATUSES_IGNORE

#if defined(__cplusplus)
} // For: extern "C" {
#endif
